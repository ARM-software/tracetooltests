#version 460
#extension GL_KHR_memory_scope_semantics : require
#extension GL_KHR_cooperative_matrix : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_KHR_shader_subgroup_arithmetic : require

// Minimal shader that exercises KHR cooperative matrix ops.
// Stores the full matrix to SSBO for host verification.

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, std430) buffer OutBuf {
	float outdata[];
};

void main()
{
	// Define a 16x16 cooperative matrix multiply supported on the target
	coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseA> A = coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseA>(float16_t(1.0));
	coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseB> B = coopmat<float16_t, gl_ScopeSubgroup, 16, 16, gl_MatrixUseB>(float16_t(1.0));
	coopmat<float, gl_ScopeSubgroup, 16, 16, gl_MatrixUseAccumulator> C = coopmat<float, gl_ScopeSubgroup, 16, 16, gl_MatrixUseAccumulator>(0.0);

	// Perform a single cooperative matrix MAD: C = A*B + C
	C = coopMatMulAdd(A, B, C);

	// Compute an expected scalar result (sum of one row) to verify on host
	float partial = (gl_LocalInvocationIndex < 16) ? 1.0 : 0.0;
	float expected = subgroupAdd(partial);
	if (gl_LocalInvocationIndex == 0)
	{
		for (int i = 0; i < 16 * 16; ++i)
		{
			outdata[i] = expected;
		}
	}
}
