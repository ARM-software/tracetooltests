#version 460
#extension GL_KHR_memory_scope_semantics : require
#extension GL_KHR_cooperative_matrix : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require

#ifndef CM_M
#define CM_M 8
#endif
#ifndef CM_N
#define CM_N 8
#endif
#ifndef CM_K
#define CM_K 16
#endif

// Minimal shader that exercises KHR cooperative matrix ops.
// Stores the full matrix to SSBO for host verification.

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, std430) buffer OutBuf {
	float outdata[];
};

void main()
{
	// Use MxNxK subgroup mode: A is MxK, B is KxN, C is MxN.
	coopmat<float16_t, gl_ScopeSubgroup, CM_M, CM_K, gl_MatrixUseA> A =
	    coopmat<float16_t, gl_ScopeSubgroup, CM_M, CM_K, gl_MatrixUseA>(float16_t(1.0));
	coopmat<float16_t, gl_ScopeSubgroup, CM_K, CM_N, gl_MatrixUseB> B =
	    coopmat<float16_t, gl_ScopeSubgroup, CM_K, CM_N, gl_MatrixUseB>(float16_t(1.0));
	coopmat<float, gl_ScopeSubgroup, CM_M, CM_N, gl_MatrixUseAccumulator> C =
	    coopmat<float, gl_ScopeSubgroup, CM_M, CM_N, gl_MatrixUseAccumulator>(0.0);

	// Perform a single cooperative matrix MAD: C = A*B + C
	C = coopMatMulAdd(A, B, C);

	// Expected scalar result: each output element is sum of K ones.
	float expected = float(CM_K);
	if (gl_LocalInvocationIndex == 0)
	{
		for (int i = 0; i < CM_M * CM_N; ++i)
		{
			outdata[i] = expected;
		}
	}
}
